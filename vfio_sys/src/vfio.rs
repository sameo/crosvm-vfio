/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const VFIO_API_VERSION: u32 = 0;
pub const VFIO_TYPE1_IOMMU: u32 = 1;
pub const VFIO_SPAPR_TCE_IOMMU: u32 = 2;
pub const VFIO_TYPE1v2_IOMMU: u32 = 3;
pub const VFIO_DMA_CC_IOMMU: u32 = 4;
pub const VFIO_EEH: u32 = 5;
pub const VFIO_TYPE1_NESTING_IOMMU: u32 = 6;
pub const VFIO_SPAPR_TCE_v2_IOMMU: u32 = 7;
pub const VFIO_NOIOMMU_IOMMU: u32 = 8;
pub const VFIO_TYPE: u32 = 59;
pub const VFIO_BASE: u32 = 100;
pub const VFIO_GROUP_FLAGS_VIABLE: u32 = 1;
pub const VFIO_GROUP_FLAGS_CONTAINER_SET: u32 = 2;
pub const VFIO_DEVICE_FLAGS_RESET: u32 = 1;
pub const VFIO_DEVICE_FLAGS_PCI: u32 = 2;
pub const VFIO_DEVICE_FLAGS_PLATFORM: u32 = 4;
pub const VFIO_DEVICE_FLAGS_AMBA: u32 = 8;
pub const VFIO_DEVICE_FLAGS_CCW: u32 = 16;
pub const VFIO_DEVICE_API_PCI_STRING: &'static [u8; 9usize] = b"vfio-pci\0";
pub const VFIO_DEVICE_API_PLATFORM_STRING: &'static [u8; 14usize] = b"vfio-platform\0";
pub const VFIO_DEVICE_API_AMBA_STRING: &'static [u8; 10usize] = b"vfio-amba\0";
pub const VFIO_DEVICE_API_CCW_STRING: &'static [u8; 9usize] = b"vfio-ccw\0";
pub const VFIO_REGION_INFO_FLAG_READ: u32 = 1;
pub const VFIO_REGION_INFO_FLAG_WRITE: u32 = 2;
pub const VFIO_REGION_INFO_FLAG_MMAP: u32 = 4;
pub const VFIO_REGION_INFO_FLAG_CAPS: u32 = 8;
pub const VFIO_REGION_INFO_CAP_SPARSE_MMAP: u32 = 1;
pub const VFIO_REGION_INFO_CAP_TYPE: u32 = 2;
pub const VFIO_REGION_TYPE_PCI_VENDOR_TYPE: u32 = 2147483648;
pub const VFIO_REGION_TYPE_PCI_VENDOR_MASK: u32 = 65535;
pub const VFIO_REGION_SUBTYPE_INTEL_IGD_OPREGION: u32 = 1;
pub const VFIO_REGION_SUBTYPE_INTEL_IGD_HOST_CFG: u32 = 2;
pub const VFIO_REGION_SUBTYPE_INTEL_IGD_LPC_CFG: u32 = 3;
pub const VFIO_REGION_INFO_CAP_MSIX_MAPPABLE: u32 = 3;
pub const VFIO_IRQ_INFO_EVENTFD: u32 = 1;
pub const VFIO_IRQ_INFO_MASKABLE: u32 = 2;
pub const VFIO_IRQ_INFO_AUTOMASKED: u32 = 4;
pub const VFIO_IRQ_INFO_NORESIZE: u32 = 8;
pub const VFIO_IRQ_SET_DATA_NONE: u32 = 1;
pub const VFIO_IRQ_SET_DATA_BOOL: u32 = 2;
pub const VFIO_IRQ_SET_DATA_EVENTFD: u32 = 4;
pub const VFIO_IRQ_SET_ACTION_MASK: u32 = 8;
pub const VFIO_IRQ_SET_ACTION_UNMASK: u32 = 16;
pub const VFIO_IRQ_SET_ACTION_TRIGGER: u32 = 32;
pub const VFIO_IRQ_SET_DATA_TYPE_MASK: u32 = 7;
pub const VFIO_IRQ_SET_ACTION_TYPE_MASK: u32 = 56;
pub const VFIO_GFX_PLANE_TYPE_PROBE: u32 = 1;
pub const VFIO_GFX_PLANE_TYPE_DMABUF: u32 = 2;
pub const VFIO_GFX_PLANE_TYPE_REGION: u32 = 4;
pub const VFIO_DEVICE_IOEVENTFD_8: u32 = 1;
pub const VFIO_DEVICE_IOEVENTFD_16: u32 = 2;
pub const VFIO_DEVICE_IOEVENTFD_32: u32 = 4;
pub const VFIO_DEVICE_IOEVENTFD_64: u32 = 8;
pub const VFIO_DEVICE_IOEVENTFD_SIZE_MASK: u32 = 15;
pub const VFIO_IOMMU_INFO_PGSIZES: u32 = 1;
pub const VFIO_DMA_MAP_FLAG_READ: u32 = 1;
pub const VFIO_DMA_MAP_FLAG_WRITE: u32 = 2;
pub const VFIO_IOMMU_SPAPR_INFO_DDW: u32 = 1;
pub const VFIO_EEH_PE_DISABLE: u32 = 0;
pub const VFIO_EEH_PE_ENABLE: u32 = 1;
pub const VFIO_EEH_PE_UNFREEZE_IO: u32 = 2;
pub const VFIO_EEH_PE_UNFREEZE_DMA: u32 = 3;
pub const VFIO_EEH_PE_GET_STATE: u32 = 4;
pub const VFIO_EEH_PE_STATE_NORMAL: u32 = 0;
pub const VFIO_EEH_PE_STATE_RESET: u32 = 1;
pub const VFIO_EEH_PE_STATE_STOPPED: u32 = 2;
pub const VFIO_EEH_PE_STATE_STOPPED_DMA: u32 = 4;
pub const VFIO_EEH_PE_STATE_UNAVAIL: u32 = 5;
pub const VFIO_EEH_PE_RESET_DEACTIVATE: u32 = 5;
pub const VFIO_EEH_PE_RESET_HOT: u32 = 6;
pub const VFIO_EEH_PE_RESET_FUNDAMENTAL: u32 = 7;
pub const VFIO_EEH_PE_CONFIGURE: u32 = 8;
pub const VFIO_EEH_PE_INJECT_ERR: u32 = 9;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_info_cap_header {
    pub id: __u16,
    pub version: __u16,
    pub next: __u32,
}
#[test]
fn bindgen_test_layout_vfio_info_cap_header() {
    assert_eq!(
        ::std::mem::size_of::<vfio_info_cap_header>(),
        8usize,
        concat!("Size of: ", stringify!(vfio_info_cap_header))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_info_cap_header>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_info_cap_header))
    );
}
#[doc = " VFIO_GROUP_GET_STATUS - _IOR(VFIO_TYPE, VFIO_BASE + 3,"]
#[doc = "\t\t\t\t\t\tstruct vfio_group_status)"]
#[doc = ""]
#[doc = " Retrieve information about the group.  Fills in provided"]
#[doc = " struct vfio_group_info.  Caller sets argsz."]
#[doc = " Return: 0 on succes, -errno on failure."]
#[doc = " Availability: Always"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_group_status {
    pub argsz: __u32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_vfio_group_status() {
    assert_eq!(
        ::std::mem::size_of::<vfio_group_status>(),
        8usize,
        concat!("Size of: ", stringify!(vfio_group_status))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_group_status>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_group_status))
    );
}
#[doc = " VFIO_DEVICE_GET_INFO - _IOR(VFIO_TYPE, VFIO_BASE + 7,"]
#[doc = "\t\t\t\t\t\tstruct vfio_device_info)"]
#[doc = ""]
#[doc = " Retrieve information about the device.  Fills in provided"]
#[doc = " struct vfio_device_info.  Caller sets argsz."]
#[doc = " Return: 0 on success, -errno on failure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_device_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub num_regions: __u32,
    pub num_irqs: __u32,
}
#[test]
fn bindgen_test_layout_vfio_device_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_device_info>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_device_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_device_info>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_device_info))
    );
}
#[doc = " VFIO_DEVICE_GET_REGION_INFO - _IOWR(VFIO_TYPE, VFIO_BASE + 8,"]
#[doc = "\t\t\t\t       struct vfio_region_info)"]
#[doc = ""]
#[doc = " Retrieve information about a device region.  Caller provides"]
#[doc = " struct vfio_region_info with index value set.  Caller sets argsz."]
#[doc = " Implementation of region mapping is bus driver specific.  This is"]
#[doc = " intended to describe MMIO, I/O port, as well as bus specific"]
#[doc = " regions (ex. PCI config space).  Zero sized regions may be used"]
#[doc = " to describe unimplemented regions (ex. unimplemented PCI BARs)."]
#[doc = " Return: 0 on success, -errno on failure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_region_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub index: __u32,
    pub cap_offset: __u32,
    pub size: __u64,
    pub offset: __u64,
}
#[test]
fn bindgen_test_layout_vfio_region_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_region_info>(),
        32usize,
        concat!("Size of: ", stringify!(vfio_region_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_region_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_region_info))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_region_sparse_mmap_area {
    pub offset: __u64,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_vfio_region_sparse_mmap_area() {
    assert_eq!(
        ::std::mem::size_of::<vfio_region_sparse_mmap_area>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_region_sparse_mmap_area))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_region_sparse_mmap_area>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_region_sparse_mmap_area))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default)]
pub struct vfio_region_info_cap_sparse_mmap {
    pub header: vfio_info_cap_header,
    pub nr_areas: __u32,
    pub reserved: __u32,
    pub areas: __IncompleteArrayField<vfio_region_sparse_mmap_area>,
}
#[test]
fn bindgen_test_layout_vfio_region_info_cap_sparse_mmap() {
    assert_eq!(
        ::std::mem::size_of::<vfio_region_info_cap_sparse_mmap>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_region_info_cap_sparse_mmap))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_region_info_cap_sparse_mmap>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vfio_region_info_cap_sparse_mmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_region_info_cap_type {
    pub header: vfio_info_cap_header,
    pub type_: __u32,
    pub subtype: __u32,
}
#[test]
fn bindgen_test_layout_vfio_region_info_cap_type() {
    assert_eq!(
        ::std::mem::size_of::<vfio_region_info_cap_type>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_region_info_cap_type))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_region_info_cap_type>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_region_info_cap_type))
    );
}
#[doc = " VFIO_DEVICE_GET_IRQ_INFO - _IOWR(VFIO_TYPE, VFIO_BASE + 9,"]
#[doc = "\t\t\t\t    struct vfio_irq_info)"]
#[doc = ""]
#[doc = " Retrieve information about a device IRQ.  Caller provides"]
#[doc = " struct vfio_irq_info with index value set.  Caller sets argsz."]
#[doc = " Implementation of IRQ mapping is bus driver specific.  Indexes"]
#[doc = " using multiple IRQs are primarily intended to support MSI-like"]
#[doc = " interrupt blocks.  Zero count irq blocks may be used to describe"]
#[doc = " unimplemented interrupt types."]
#[doc = ""]
#[doc = " The EVENTFD flag indicates the interrupt index supports eventfd based"]
#[doc = " signaling."]
#[doc = ""]
#[doc = " The MASKABLE flags indicates the index supports MASK and UNMASK"]
#[doc = " actions described below."]
#[doc = ""]
#[doc = " AUTOMASKED indicates that after signaling, the interrupt line is"]
#[doc = " automatically masked by VFIO and the user needs to unmask the line"]
#[doc = " to receive new interrupts.  This is primarily intended to distinguish"]
#[doc = " level triggered interrupts."]
#[doc = ""]
#[doc = " The NORESIZE flag indicates that the interrupt lines within the index"]
#[doc = " are setup as a set and new subindexes cannot be enabled without first"]
#[doc = " disabling the entire index.  This is used for interrupts like PCI MSI"]
#[doc = " and MSI-X where the driver may only use a subset of the available"]
#[doc = " indexes, but VFIO needs to enable a specific number of vectors"]
#[doc = " upfront.  In the case of MSI-X, where the user can enable MSI-X and"]
#[doc = " then add and unmask vectors, it's up to userspace to make the decision"]
#[doc = " whether to allocate the maximum supported number of vectors or tear"]
#[doc = " down setup and incrementally increase the vectors as each is enabled."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_irq_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub index: __u32,
    pub count: __u32,
}
#[test]
fn bindgen_test_layout_vfio_irq_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_irq_info>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_irq_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_irq_info>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_irq_info))
    );
}
#[doc = " VFIO_DEVICE_SET_IRQS - _IOW(VFIO_TYPE, VFIO_BASE + 10, struct vfio_irq_set)"]
#[doc = ""]
#[doc = " Set signaling, masking, and unmasking of interrupts.  Caller provides"]
#[doc = " struct vfio_irq_set with all fields set.  'start' and 'count' indicate"]
#[doc = " the range of subindexes being specified."]
#[doc = ""]
#[doc = " The DATA flags specify the type of data provided.  If DATA_NONE, the"]
#[doc = " operation performs the specified action immediately on the specified"]
#[doc = " interrupt(s).  For example, to unmask AUTOMASKED interrupt [0,0]:"]
#[doc = " flags = (DATA_NONE|ACTION_UNMASK), index = 0, start = 0, count = 1."]
#[doc = ""]
#[doc = " DATA_BOOL allows sparse support for the same on arrays of interrupts."]
#[doc = " For example, to mask interrupts [0,1] and [0,3] (but not [0,2]):"]
#[doc = " flags = (DATA_BOOL|ACTION_MASK), index = 0, start = 1, count = 3,"]
#[doc = " data = {1,0,1}"]
#[doc = ""]
#[doc = " DATA_EVENTFD binds the specified ACTION to the provided __s32 eventfd."]
#[doc = " A value of -1 can be used to either de-assign interrupts if already"]
#[doc = " assigned or skip un-assigned interrupts.  For example, to set an eventfd"]
#[doc = " to be trigger for interrupts [0,0] and [0,2]:"]
#[doc = " flags = (DATA_EVENTFD|ACTION_TRIGGER), index = 0, start = 0, count = 3,"]
#[doc = " data = {fd1, -1, fd2}"]
#[doc = " If index [0,1] is previously set, two count = 1 ioctls calls would be"]
#[doc = " required to set [0,0] and [0,2] without changing [0,1]."]
#[doc = ""]
#[doc = " Once a signaling mechanism is set, DATA_BOOL or DATA_NONE can be used"]
#[doc = " with ACTION_TRIGGER to perform kernel level interrupt loopback testing"]
#[doc = " from userspace (ie. simulate hardware triggering)."]
#[doc = ""]
#[doc = " Setting of an event triggering mechanism to userspace for ACTION_TRIGGER"]
#[doc = " enables the interrupt index for the device.  Individual subindex interrupts"]
#[doc = " can be disabled using the -1 value for DATA_EVENTFD or the index can be"]
#[doc = " disabled as a whole with: flags = (DATA_NONE|ACTION_TRIGGER), count = 0."]
#[doc = ""]
#[doc = " Note that ACTION_[UN]MASK specify user->kernel signaling (irqfds) while"]
#[doc = " ACTION_TRIGGER specifies kernel->user signaling."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct vfio_irq_set {
    pub argsz: __u32,
    pub flags: __u32,
    pub index: __u32,
    pub start: __u32,
    pub count: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_vfio_irq_set() {
    assert_eq!(
        ::std::mem::size_of::<vfio_irq_set>(),
        20usize,
        concat!("Size of: ", stringify!(vfio_irq_set))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_irq_set>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_irq_set))
    );
}
pub const VFIO_PCI_BAR0_REGION_INDEX: _bindgen_ty_1 = 0;
pub const VFIO_PCI_BAR1_REGION_INDEX: _bindgen_ty_1 = 1;
pub const VFIO_PCI_BAR2_REGION_INDEX: _bindgen_ty_1 = 2;
pub const VFIO_PCI_BAR3_REGION_INDEX: _bindgen_ty_1 = 3;
pub const VFIO_PCI_BAR4_REGION_INDEX: _bindgen_ty_1 = 4;
pub const VFIO_PCI_BAR5_REGION_INDEX: _bindgen_ty_1 = 5;
pub const VFIO_PCI_ROM_REGION_INDEX: _bindgen_ty_1 = 6;
pub const VFIO_PCI_CONFIG_REGION_INDEX: _bindgen_ty_1 = 7;
pub const VFIO_PCI_VGA_REGION_INDEX: _bindgen_ty_1 = 8;
pub const VFIO_PCI_NUM_REGIONS: _bindgen_ty_1 = 9;
pub type _bindgen_ty_1 = u32;
pub const VFIO_PCI_INTX_IRQ_INDEX: _bindgen_ty_2 = 0;
pub const VFIO_PCI_MSI_IRQ_INDEX: _bindgen_ty_2 = 1;
pub const VFIO_PCI_MSIX_IRQ_INDEX: _bindgen_ty_2 = 2;
pub const VFIO_PCI_ERR_IRQ_INDEX: _bindgen_ty_2 = 3;
pub const VFIO_PCI_REQ_IRQ_INDEX: _bindgen_ty_2 = 4;
pub const VFIO_PCI_NUM_IRQS: _bindgen_ty_2 = 5;
pub type _bindgen_ty_2 = u32;
pub const VFIO_CCW_CONFIG_REGION_INDEX: _bindgen_ty_3 = 0;
pub const VFIO_CCW_NUM_REGIONS: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = u32;
pub const VFIO_CCW_IO_IRQ_INDEX: _bindgen_ty_4 = 0;
pub const VFIO_CCW_NUM_IRQS: _bindgen_ty_4 = 1;
pub type _bindgen_ty_4 = u32;
#[doc = " VFIO_DEVICE_GET_PCI_HOT_RESET_INFO - _IORW(VFIO_TYPE, VFIO_BASE + 12,"]
#[doc = "\t\t\t\t\t      struct vfio_pci_hot_reset_info)"]
#[doc = ""]
#[doc = " Return: 0 on success, -errno on failure:"]
#[doc = "\t-enospc = insufficient buffer, -enodev = unsupported for device."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_pci_dependent_device {
    pub group_id: __u32,
    pub segment: __u16,
    pub bus: __u8,
    pub devfn: __u8,
}
#[test]
fn bindgen_test_layout_vfio_pci_dependent_device() {
    assert_eq!(
        ::std::mem::size_of::<vfio_pci_dependent_device>(),
        8usize,
        concat!("Size of: ", stringify!(vfio_pci_dependent_device))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_pci_dependent_device>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_pci_dependent_device))
    );
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct vfio_pci_hot_reset_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub count: __u32,
    pub devices: __IncompleteArrayField<vfio_pci_dependent_device>,
}
#[test]
fn bindgen_test_layout_vfio_pci_hot_reset_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_pci_hot_reset_info>(),
        12usize,
        concat!("Size of: ", stringify!(vfio_pci_hot_reset_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_pci_hot_reset_info>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_pci_hot_reset_info))
    );
}
#[doc = " VFIO_DEVICE_PCI_HOT_RESET - _IOW(VFIO_TYPE, VFIO_BASE + 13,"]
#[doc = "\t\t\t\t    struct vfio_pci_hot_reset)"]
#[doc = ""]
#[doc = " Return: 0 on success, -errno on failure."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct vfio_pci_hot_reset {
    pub argsz: __u32,
    pub flags: __u32,
    pub count: __u32,
    pub group_fds: __IncompleteArrayField<__s32>,
}
#[test]
fn bindgen_test_layout_vfio_pci_hot_reset() {
    assert_eq!(
        ::std::mem::size_of::<vfio_pci_hot_reset>(),
        12usize,
        concat!("Size of: ", stringify!(vfio_pci_hot_reset))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_pci_hot_reset>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_pci_hot_reset))
    );
}
#[doc = " VFIO_DEVICE_QUERY_GFX_PLANE - _IOW(VFIO_TYPE, VFIO_BASE + 14,"]
#[doc = "                                    struct vfio_device_query_gfx_plane)"]
#[doc = ""]
#[doc = " Set the drm_plane_type and flags, then retrieve the gfx plane info."]
#[doc = ""]
#[doc = " flags supported:"]
#[doc = " - VFIO_GFX_PLANE_TYPE_PROBE and VFIO_GFX_PLANE_TYPE_DMABUF are set"]
#[doc = "   to ask if the mdev supports dma-buf. 0 on support, -EINVAL on no"]
#[doc = "   support for dma-buf."]
#[doc = " - VFIO_GFX_PLANE_TYPE_PROBE and VFIO_GFX_PLANE_TYPE_REGION are set"]
#[doc = "   to ask if the mdev supports region. 0 on support, -EINVAL on no"]
#[doc = "   support for region."]
#[doc = " - VFIO_GFX_PLANE_TYPE_DMABUF or VFIO_GFX_PLANE_TYPE_REGION is set"]
#[doc = "   with each call to query the plane info."]
#[doc = " - Others are invalid and return -EINVAL."]
#[doc = ""]
#[doc = " Note:"]
#[doc = " 1. Plane could be disabled by guest. In that case, success will be"]
#[doc = "    returned with zero-initialized drm_format, size, width and height"]
#[doc = "    fields."]
#[doc = " 2. x_hot/y_hot is set to 0xFFFFFFFF if no hotspot information available"]
#[doc = ""]
#[doc = " Return: 0 on success, -errno on other failure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfio_device_gfx_plane_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub drm_plane_type: __u32,
    pub drm_format: __u32,
    pub drm_format_mod: __u64,
    pub width: __u32,
    pub height: __u32,
    pub stride: __u32,
    pub size: __u32,
    pub x_pos: __u32,
    pub y_pos: __u32,
    pub x_hot: __u32,
    pub y_hot: __u32,
    pub __bindgen_anon_1: vfio_device_gfx_plane_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vfio_device_gfx_plane_info__bindgen_ty_1 {
    pub region_index: __u32,
    pub dmabuf_id: __u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_vfio_device_gfx_plane_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfio_device_gfx_plane_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(vfio_device_gfx_plane_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_device_gfx_plane_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vfio_device_gfx_plane_info__bindgen_ty_1)
        )
    );
}
impl Default for vfio_device_gfx_plane_info__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_vfio_device_gfx_plane_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_device_gfx_plane_info>(),
        64usize,
        concat!("Size of: ", stringify!(vfio_device_gfx_plane_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_device_gfx_plane_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_device_gfx_plane_info))
    );
}
impl Default for vfio_device_gfx_plane_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " VFIO_DEVICE_IOEVENTFD - _IOW(VFIO_TYPE, VFIO_BASE + 16,"]
#[doc = "                              struct vfio_device_ioeventfd)"]
#[doc = ""]
#[doc = " Perform a write to the device at the specified device fd offset, with"]
#[doc = " the specified data and width when the provided eventfd is triggered."]
#[doc = " vfio bus drivers may not support this for all regions, for all widths,"]
#[doc = " or at all.  vfio-pci currently only enables support for BAR regions,"]
#[doc = " excluding the MSI-X vector table."]
#[doc = ""]
#[doc = " Return: 0 on success, -errno on failure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_device_ioeventfd {
    pub argsz: __u32,
    pub flags: __u32,
    pub offset: __u64,
    pub data: __u64,
    pub fd: __s32,
}
#[test]
fn bindgen_test_layout_vfio_device_ioeventfd() {
    assert_eq!(
        ::std::mem::size_of::<vfio_device_ioeventfd>(),
        32usize,
        concat!("Size of: ", stringify!(vfio_device_ioeventfd))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_device_ioeventfd>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_device_ioeventfd))
    );
}
#[doc = " VFIO_IOMMU_GET_INFO - _IOR(VFIO_TYPE, VFIO_BASE + 12, struct vfio_iommu_info)"]
#[doc = ""]
#[doc = " Retrieve information about the IOMMU object. Fills in provided"]
#[doc = " struct vfio_iommu_info. Caller sets argsz."]
#[doc = ""]
#[doc = " XXX Should we do these by CHECK_EXTENSION too?"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_iommu_type1_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub iova_pgsizes: __u64,
}
#[test]
fn bindgen_test_layout_vfio_iommu_type1_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_type1_info>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_iommu_type1_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_type1_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_type1_info))
    );
}
#[doc = " VFIO_IOMMU_MAP_DMA - _IOW(VFIO_TYPE, VFIO_BASE + 13, struct vfio_dma_map)"]
#[doc = ""]
#[doc = " Map process virtual addresses to IO virtual addresses using the"]
#[doc = " provided struct vfio_dma_map. Caller sets argsz. READ &/ WRITE required."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_iommu_type1_dma_map {
    pub argsz: __u32,
    pub flags: __u32,
    pub vaddr: __u64,
    pub iova: __u64,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_vfio_iommu_type1_dma_map() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_type1_dma_map>(),
        32usize,
        concat!("Size of: ", stringify!(vfio_iommu_type1_dma_map))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_type1_dma_map>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_type1_dma_map))
    );
}
#[doc = " VFIO_IOMMU_UNMAP_DMA - _IOWR(VFIO_TYPE, VFIO_BASE + 14,"]
#[doc = "\t\t\t\t\t\t\tstruct vfio_dma_unmap)"]
#[doc = ""]
#[doc = " Unmap IO virtual addresses using the provided struct vfio_dma_unmap."]
#[doc = " Caller sets argsz.  The actual unmapped size is returned in the size"]
#[doc = " field.  No guarantee is made to the user that arbitrary unmaps of iova"]
#[doc = " or size different from those used in the original mapping call will"]
#[doc = " succeed."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_iommu_type1_dma_unmap {
    pub argsz: __u32,
    pub flags: __u32,
    pub iova: __u64,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_vfio_iommu_type1_dma_unmap() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_type1_dma_unmap>(),
        24usize,
        concat!("Size of: ", stringify!(vfio_iommu_type1_dma_unmap))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_type1_dma_unmap>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_type1_dma_unmap))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_iommu_spapr_tce_ddw_info {
    pub pgsizes: __u64,
    pub max_dynamic_windows_supported: __u32,
    pub levels: __u32,
}
#[test]
fn bindgen_test_layout_vfio_iommu_spapr_tce_ddw_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_spapr_tce_ddw_info>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_iommu_spapr_tce_ddw_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_spapr_tce_ddw_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_spapr_tce_ddw_info))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_iommu_spapr_tce_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub dma32_window_start: __u32,
    pub dma32_window_size: __u32,
    pub ddw: vfio_iommu_spapr_tce_ddw_info,
}
#[test]
fn bindgen_test_layout_vfio_iommu_spapr_tce_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_spapr_tce_info>(),
        32usize,
        concat!("Size of: ", stringify!(vfio_iommu_spapr_tce_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_spapr_tce_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_spapr_tce_info))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_eeh_pe_err {
    pub type_: __u32,
    pub func: __u32,
    pub addr: __u64,
    pub mask: __u64,
}
#[test]
fn bindgen_test_layout_vfio_eeh_pe_err() {
    assert_eq!(
        ::std::mem::size_of::<vfio_eeh_pe_err>(),
        24usize,
        concat!("Size of: ", stringify!(vfio_eeh_pe_err))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_eeh_pe_err>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_eeh_pe_err))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfio_eeh_pe_op {
    pub argsz: __u32,
    pub flags: __u32,
    pub op: __u32,
    pub __bindgen_anon_1: vfio_eeh_pe_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vfio_eeh_pe_op__bindgen_ty_1 {
    pub err: vfio_eeh_pe_err,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_vfio_eeh_pe_op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfio_eeh_pe_op__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(vfio_eeh_pe_op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_eeh_pe_op__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_eeh_pe_op__bindgen_ty_1))
    );
}
impl Default for vfio_eeh_pe_op__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_vfio_eeh_pe_op() {
    assert_eq!(
        ::std::mem::size_of::<vfio_eeh_pe_op>(),
        40usize,
        concat!("Size of: ", stringify!(vfio_eeh_pe_op))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_eeh_pe_op>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_eeh_pe_op))
    );
}
impl Default for vfio_eeh_pe_op {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " VFIO_IOMMU_SPAPR_REGISTER_MEMORY - _IOW(VFIO_TYPE, VFIO_BASE + 17, struct vfio_iommu_spapr_register_memory)"]
#[doc = ""]
#[doc = " Registers user space memory where DMA is allowed. It pins"]
#[doc = " user pages and does the locked memory accounting so"]
#[doc = " subsequent VFIO_IOMMU_MAP_DMA/VFIO_IOMMU_UNMAP_DMA calls"]
#[doc = " get faster."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_iommu_spapr_register_memory {
    pub argsz: __u32,
    pub flags: __u32,
    pub vaddr: __u64,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_vfio_iommu_spapr_register_memory() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_spapr_register_memory>(),
        24usize,
        concat!("Size of: ", stringify!(vfio_iommu_spapr_register_memory))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_spapr_register_memory>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vfio_iommu_spapr_register_memory)
        )
    );
}
#[doc = " VFIO_IOMMU_SPAPR_TCE_CREATE - _IOWR(VFIO_TYPE, VFIO_BASE + 19, struct vfio_iommu_spapr_tce_create)"]
#[doc = ""]
#[doc = " Creates an additional TCE table and programs it (sets a new DMA window)"]
#[doc = " to every IOMMU group in the container. It receives page shift, window"]
#[doc = " size and number of levels in the TCE table being created."]
#[doc = ""]
#[doc = " It allocates and returns an offset on a PCI bus of the new DMA window."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_iommu_spapr_tce_create {
    pub argsz: __u32,
    pub flags: __u32,
    pub page_shift: __u32,
    pub __resv1: __u32,
    pub window_size: __u64,
    pub levels: __u32,
    pub __resv2: __u32,
    pub start_addr: __u64,
}
#[test]
fn bindgen_test_layout_vfio_iommu_spapr_tce_create() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_spapr_tce_create>(),
        40usize,
        concat!("Size of: ", stringify!(vfio_iommu_spapr_tce_create))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_spapr_tce_create>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_spapr_tce_create))
    );
}
#[doc = " VFIO_IOMMU_SPAPR_TCE_REMOVE - _IOW(VFIO_TYPE, VFIO_BASE + 20, struct vfio_iommu_spapr_tce_remove)"]
#[doc = ""]
#[doc = " Unprograms a TCE table from all groups in the container and destroys it."]
#[doc = " It receives a PCI bus offset as a window id."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfio_iommu_spapr_tce_remove {
    pub argsz: __u32,
    pub flags: __u32,
    pub start_addr: __u64,
}
#[test]
fn bindgen_test_layout_vfio_iommu_spapr_tce_remove() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_spapr_tce_remove>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_iommu_spapr_tce_remove))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_spapr_tce_remove>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_spapr_tce_remove))
    );
}
